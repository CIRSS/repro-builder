

# returns seconds since the epoch
function repro.timestamp_seconds {
    echo $(date +"%s")
}

# returns a time-sortable dated timestamp
function repro.timestamp {
    echo $(date +"%Y-%m-%d %T")
}

function repro.info {
    echo $(repro.timestamp) INFO $*
}

function repro.initialize_state {
    mkdir -p ${REPRO_STATE_DIR}
    repro.timestamp > ${REPRO_START_TIME}
    repro.update_path
    repro.initialize_modules
    repro.update_targets
    repro.start_services --at-start
}

function repro.get_prefix_paths {
    unset prefix_paths
    readarray paths < ${REPRO_PATH_FILE}
    for path_line in "${paths[@]}" ; do
        new_path=$(echo "$path_line" | envsubst | xargs )
        if [[ -vprefix_paths ]] ; then
           prefix_paths=${new_path}:${prefix_paths}
        else
           prefix_paths=${new_path}
        fi
    done
    echo ${prefix_paths}
}

function repro.module_install_dir {
    module_name=$1
    read -ra tokens < ${REPRO_INDEX_DIR}/${module_name}
    module_install_dir=${tokens[2]}
    echo ${module_install_dir}
}

function repro.module_dot_dir {
    module_name=$1
    dot_dir=${REPRO_MNT}/.${module_name}
    echo ${dot_dir}
}

function repro.get_module_paths {
    unset module_paths
    readarray modules < ${REPRO_ORDER_FILE}
    for module_name in "${modules[@]}" ; do
        module_install_dir=$(repro.module_install_dir ${module_name})
        if [[ -v module_paths ]] ; then
            module_paths=${module_install_dir}:${module_paths}
        else
            module_paths=${module_install_dir}
        fi
    done
    echo ${module_paths}
}

function repro.update_path {

    updated_path=${REPRO_BASE_PATH}

    module_paths=$(repro.get_module_paths)
    if [[ ! -z ${module_paths} ]] ; then
        updated_path=${module_paths}:${updated_path}
    fi

   prefix_paths=$(repro.get_prefix_paths)
    if [[ ! -z ${prefix_paths} ]] ; then
        updated_path=${prefix_paths}:${updated_path}
    fi

    export PATH=${updated_path}
}

function ensure_nullglob {
    shopt -q nullglob
    if [[ $? == 1 ]] ; then
        null_glob_was_enabled=true
        shopt -s nullglob
    fi
}

function restore_nullglob {
    if [[ -v null_glob_was_enabled ]] ; then
        shopt -u nullglob
        unset null_glob_was_enabled
    fi
}

function repro.initialize_module_trim {

    module_name=$1

    # create module dot directory if it does not exist
    dot_dir=$(repro.module_dot_dir ${module_name})
    [[ -d ${dot_dir} ]] || mkdir -p ${dot_dir}

    # include a default .gitignore file
    git_ignore_file=${dot_dir}/.gitignore
    [[ -f ${git_ignore_file} ]] || echo "*" > ${git_ignore_file}

    # include any Makefiles found in the module installation directory
    install_dir=$(repro.module_install_dir ${module_name})
    ensure_nullglob
    makefiles=( ${install_dir}/Makefile-* )
    for makefile_path in "${makefiles[@]}" ; do
        makefile_name=$(basename ${makefile_path})
        cp --no-clobber ${install_dir}/${makefile_name} ${dot_dir}/${makefile_name}
    done
    restore_nullglob

    # copy module files listed in trun manifest if present
    trim_manifest=${install_dir}/manifest-trim
    if [[ -f ${trim_manifest} ]] ; then
        readarray trim_manifest_lines < ${trim_manifest}
        for trim_file_line in "${trim_manifest_lines[@]}" ; do
            trim_file=$(echo ${trim_file_line%%#*} | xargs)
            if [[ -n ${trim_file} ]] ; then
                cp --no-clobber ${install_dir}/${trim_file} ${dot_dir}/${trim_file}
            fi
        done
    fi

}

function repro.initialize_modules {
    readarray modules < ${REPRO_ORDER_FILE}
    for module in "${modules[@]}" ; do
        repro.initialize_module_trim ${module}
    done
}

function repro.update_targets {

    # do nothing if targets file already exists
    if [[ -f ${REPRO_TARGETS_FILE} ]] ; then
        return
    else
        repro_builder_install_dir=$(repro.module_install_dir repro)
        cp  ${repro_builder_install_dir}/${REPRO_TARGETS_FILENAME} ${REPRO_TARGETS_FILE}
    fi

    readarray modules < ${REPRO_ORDER_FILE}
    for modules_line in "${modules[@]}" ; do
        module_name=$(echo $modules_line | xargs)
        install_dir=$(repro.module_install_dir ${module_name})

        for profile in base trim code demos util; do
            module_targets_file=${install_dir}/targets-${profile}
            if [[ -f ${module_targets_file} ]] ; then
                repro_targets=''
                readarray module_targets < ${module_targets_file}
                for target_entry in "${module_targets[@]}" ; do
                    read -ra tokens <<< ${target_entry}
                    repro_target=${tokens[0]}
                    module_target=${tokens[1]}
                    printf '%s %s.%s.%s\n' ${repro_target} ${module_name} ${profile} ${module_target} >> ${REPRO_TARGETS_FILE}
                done
            fi
        done
    done
}


function repro.run_target {

    requested_target=$1
    options=$2
    [[ ! -f ${REPRO_TARGETS_FILE} ]] && return

    readarray targets_file_lines < ${REPRO_TARGETS_FILE}

    for target_entry in "${targets_file_lines[@]}" ; do
        read -ra tokens <<< ${target_entry}
        if [[ ${tokens[0]} == ${requested_target}: ]] ; then
            IFS='.' read module_name profile module_target <<< ${tokens[1]}
            make --quiet -C ${REPRO_MNT}/.${module_name} -f Makefile-${profile} ${module_target}

            if [[ ${requested_target} == "start-services" ]] ; then
                repro.record_services_start
            fi

            return
        fi
    done
    if [[ $options != "--quiet" ]] ; then
        echo "INFO: The $requested_target target is not implemented by this REPRO."
    fi
    return -1
}

function repro.announce_services {

    # nothing to do if the repro services file is missing
    [[ ! -f ${REPRO_SERVICES_FILE} ]] && return

    # write a message to the terminal for each service
    readarray lines < ${REPRO_SERVICES_FILE}
    if [[ -n "${lines}" ]] ; then
        echo "----------------------------------------------------------------------------------"
        for line in "${lines[@]}" ; do
            read service_name internal_port external_port <<< ${line}
            repro.info The ${service_name} service is now running. \
                       Connect to it at http://localhost:${external_port}.
        done
        echo "----------------------------------------------------------------------------------"
    fi
}


function repro.record_services_start {
    repro.timestamp > ${REPRO_SERVICES_START_TIME}
    repro.announce_services
}

function repro.run_start_services_target {

    repro.timestamp > ${REPRO_SERVICES_START_TIME}

}

function repro.start_services {

    # handle case where this function is being called during REPRO startup
    if [[ "$1" == "--at-start" ]] ; then

        # only start the services if auto-startup is enabled
        if [[ "${REPRO_SERVICES}" == 'auto' ]] ; then

            # use the --quiet option to hide warning when REPRO has no services
            repro.run_target start-services --quiet
        fi

        # no more to do if function was called during REPRO startup
        return
    fi

    # this function is being called after startup so start the services
    # now only if service startup is configured to be manual
    if [[ "${REPRO_SERVICES}" == 'manual' ]] ; then

        # start services and allow warning that REPRO has no services
        repro.run_target start-services

        # an error code indicates that there were no services to start
        # so there is nothing else to do
        if [[ $? -ne 0 ]] ; then
            return
        fi
    fi

    # the current call to this function started the services after REPRO
    # startup

    # wait for a key stroke before returning if requested

    if [[ "$1" == "--wait-for-key" ]] ; then
        echo "Terminate the services by pressing the 'q' key in this terminal."
        while [ true ] ; do
            read -n 1 key
            if [[ $key = 'q' ]] ; then
                echo
                exit
            else
                echo "Type 'q' key to stop the REPRO services."
            fi

        done
    fi
}
