

function repro.initialize_state { $_REPRO_TRACE_CALL_ $*
    mkdir -p ${REPRO_STATE_DIR}
    _repro.timestamp > ${REPRO_START_TIME}
    repro.update_path
    repro.initialize_modules
    repro.update_targets

	$_REPRO_DEBUG_ Triggering automatic service startup
    repro.start_services --at-start
    $_REPRO_TRACE_RETURN_
}

function repro.get_prefix_paths { $_REPRO_TRACE_CALL_ $*
    unset prefix_paths
    readarray paths < ${REPRO_PATH_FILE}
    for path_line in "${paths[@]}" ; do
        new_path=$(echo "$path_line" | envsubst | xargs )
        if [[ -vprefix_paths ]] ; then
           prefix_paths=${new_path}:${prefix_paths}
        else
           prefix_paths=${new_path}
        fi
    done
    echo ${prefix_paths}
    $_REPRO_TRACE_RETURN_
}

function repro.module_install_dir {
    module_name=$1
    read -ra tokens < ${REPRO_INDEX_DIR}/${module_name}
    module_install_dir=${tokens[2]}
    echo ${module_install_dir}
}

function repro.module_dot_dir {
    module_name=$1
    dot_dir=${REPRO_MNT}/.${module_name}
    echo ${dot_dir}
}

function repro.get_module_paths { $_REPRO_TRACE_CALL_ $*
    unset module_paths
    readarray modules < ${REPRO_ORDER_FILE}
    for module_name in "${modules[@]}" ; do
        module_install_dir=$(repro.module_install_dir ${module_name})
        if [[ -v module_paths ]] ; then
            module_paths=${module_install_dir}:${module_paths}
        else
            module_paths=${module_install_dir}
        fi
    done
    echo ${module_paths}
    $_REPRO_TRACE_RETURN_
}

function repro.update_path { $_REPRO_TRACE_CALL_ $*

    updated_path=${REPRO_BASE_PATH}

    module_paths=$(repro.get_module_paths)
    if [[ ! -z ${module_paths} ]] ; then
        updated_path=${module_paths}:${updated_path}
    fi

   prefix_paths=$(repro.get_prefix_paths)
    if [[ ! -z ${prefix_paths} ]] ; then
        updated_path=${prefix_paths}:${updated_path}
    fi

    export PATH=${updated_path}

    $_REPRO_TRACE_RETURN_
}

function ensure_nullglob {
    shopt -q nullglob
    if [[ $? == 1 ]] ; then
        null_glob_was_enabled=true
        shopt -s nullglob
    fi
}

function restore_nullglob {
    if [[ -v null_glob_was_enabled ]] ; then
        shopt -u nullglob
        unset null_glob_was_enabled
    fi
}

function repro.initialize_module_trim { $_REPRO_TRACE_CALL_ $*

	$_REPRO_INFO_ Initializing module trims

    module_name=$1

    # create module dot directory if it does not exist
    dot_dir=$(repro.module_dot_dir ${module_name})
    [[ -d ${dot_dir} ]] || mkdir -p ${dot_dir}

    # include a default .gitignore file
    git_ignore_file=${dot_dir}/.gitignore
    [[ -f ${git_ignore_file} ]] || echo "*" > ${git_ignore_file}

    # include any Makefiles found in the module installation directory
    install_dir=$(repro.module_install_dir ${module_name})
    ensure_nullglob
    makefiles=( ${install_dir}/Makefile-* )
    for makefile_path in "${makefiles[@]}" ; do
        makefile_name=$(basename ${makefile_path})
        cp --no-clobber ${install_dir}/${makefile_name} ${dot_dir}/${makefile_name}
    done
    restore_nullglob

    # copy module files listed in trun manifest if present
    trim_manifest=${install_dir}/manifest-trim
    if [[ -f ${trim_manifest} ]] ; then
        readarray trim_manifest_lines < ${trim_manifest}
        for trim_file_line in "${trim_manifest_lines[@]}" ; do
            trim_file=$(echo ${trim_file_line%%#*} | xargs)
            if [[ -n ${trim_file} ]] ; then
                cp --no-clobber ${install_dir}/${trim_file} ${dot_dir}/${trim_file}
            fi
        done
    fi

    $_REPRO_TRACE_RETURN_
}

function repro.initialize_modules { $_REPRO_TRACE_CALL_ $*
    readarray modules < ${REPRO_ORDER_FILE}
    for module in "${modules[@]}" ; do
        repro.initialize_module_trim ${module}
    done
    $_REPRO_TRACE_RETURN_
}

function repro.update_targets { $_REPRO_TRACE_CALL_ $*

    # do nothing if targets file already exists
    if [[ -f ${REPRO_TARGETS_FILE} ]] ; then
      $_REPRO_TRACE_RETURN_ "The targets file ${REPRO_TARGETS_FILE} already exists so nothing to do." ; return
    fi

    $_REPRO_DEBUG_ 'Copying the default (empty) targets file from the repro module install directory'
    repro_builder_install_dir=$(repro.module_install_dir repro)
    cp  ${repro_builder_install_dir}/${REPRO_TARGETS_FILENAME} ${REPRO_TARGETS_FILE}

    $_REPRO_DEBUG_ "Reading the module order file ${REPRO_ORDER_FILE} to get list of installed modules"
    readarray modules < ${REPRO_ORDER_FILE}

    $_REPRO_DEBUG_ "Iterating over the lines in the module order file"
    for modules_line in "${modules[@]}" ; do
        module_name=$(echo $modules_line | xargs)
        install_dir=$(repro.module_install_dir ${module_name})

        $_REPRO_DEBUG_ "Looking for targets files in module ${module_name}"
        for profile in base trim code demos util; do
            module_targets_file=${install_dir}/targets-${profile}
            if [[ -f ${module_targets_file} ]] ; then
                $_REPRO_DEBUG_ "Found ${module_targets_file}"
                repro_targets=''
                readarray module_targets < ${module_targets_file}
                for target_entry in "${module_targets[@]}" ; do
                    read -ra tokens <<< ${target_entry}
                    repro_target=${tokens[0]}
                    module_target=${tokens[1]}
                    $_REPRO_DEBUG_ "Mapping the REPRO target ${repro_target} to ${module_target} in the ${module_name} module"
                    printf '%s %s.%s.%s\n' ${repro_target} ${module_name} ${profile} ${module_target} >> ${REPRO_TARGETS_FILE}
                done
            fi
        done
    done

    $_REPRO_TRACE_RETURN_ 'Done building the REPRO target mapping file'
}

function repro.run_target { $_REPRO_TRACE_CALL_ $*

    requested_target=$1
    options=$2

    if [[ ! -f ${REPRO_TARGETS_FILE} ]] ; then
        $_REPRO_TRACE_RETURN_ "No targets file ${REPRO_TARGETS_FILE} found." ; return
    fi

    readarray targets_file_lines < ${REPRO_TARGETS_FILE}

    for target_entry in "${targets_file_lines[@]}" ; do
        read -ra tokens <<< ${target_entry}
        $_REPRO_DEBUG_ Processing line in target file: ${tokens}
        if [[ ${tokens[0]} == ${requested_target}: ]] ; then
            IFS='.' read module_name profile module_target <<< ${tokens[1]}
            make --quiet -C ${REPRO_MNT}/.${module_name} -f Makefile-${profile} ${module_target}

            if [[ ${requested_target} == "start-services" ]] ; then
                _repro.timestamp > ${REPRO_SERVICES_START_TIME}
                repro.announce_services
            fi

            $_REPRO_TRACE_RETURN_ ; return
        fi
    done
    if [[ $options != "--quiet" ]] ; then
        $_REPRO_ERROR_ "The $requested_target target is not implemented by this REPRO."
    fi

    $_REPRO_TRACE_RETURN_
}

function repro.announce_services { $_REPRO_TRACE_CALL_ $*

    # nothing to do if the repro services file is missing
    if [[ ! -f ${REPRO_SERVICES_FILE} ]] ; then
        $_REPRO_TRACE_RETURN_ "File not found: ${REPRO_SERVICES_FILE}" ; return
    fi

    # write a message to the terminal for each service
    readarray lines < ${REPRO_SERVICES_FILE}
    if [[ -n "${lines}" ]] ; then
        for line in "${lines[@]}" ; do
            read service_name internal_port external_port <<< ${line}
            $_REPRO_INFO_ The ${service_name} service is now running.
            $_REPRO_INFO_ Connect to ${service_name} at http://localhost:${external_port}.
        done
    else
        $_REPRO_DEBUG_ No registered services to start.
    fi

    $_REPRO_TRACE_RETURN_
}


function repro.start_services { $_REPRO_TRACE_CALL_ $*

    if [[ "$1" == "--at-start" ]] ; then
        $_REPRO_DEBUG_ "This function is being called during REPRO startup"

        if [[ "${REPRO_SERVICES}" == 'auto' ]] ; then
			$_REPRO_DEBUG_ 'Starting REPRO services now because REPRO_SERVICES == auto'
            $_REPRO_DEBUG_ 'Invoking the start-services target with the --quiet option to
                            hide warning when REPRO has no services'
            repro.run_target start-services --quiet
        else
			$_REPRO_DEBUG_ 'NOT starting REPRO services now because REPRO_SERVICES != auto'
		fi

        $_REPRO_TRACE_RETURN_ "Done handling repro.start_services call during REPRO startup" ; return
    fi

    $_REPRO_DEBUG_ 'This function is being called *after* REPRO startup'

    # now only if service startup is configured to be manual
    if [[ "${REPRO_SERVICES}" == 'manual' ]] ; then

		$_REPRO_DEBUG_ 'Starting REPRO services now because REPRO_SERVICES == manual'

		# start services and allow warning that REPRO has no services
        repro.run_target start-services
        return_code=$?

        # an error code indicates that there were no services to start
        # so there is nothing else to do
        if [[ $return_code -ne 0 ]] ; then
            $_REPRO_DEBUG "The return code of $return_code indicates there were no services to start"
            $_REPRO_TRACE_RETURN_ "Because no services were started there is nothing left to do"; return
        fi
    else
        $_REPRO_DEBUG_ 'NOT starting REPRO services now because REPRO_SERVICES != manual'
    fi


    if [[ "$1" == "--wait-for-key" ]] ; then
        _REPRO_DEBUG "Will now wait for a key stroke before returning because the --wait-for-key option was given"
        while [ true ] ; do
            $_REPRO_ALERT_ "Type 'q' key to stop the REPRO and its services."
            $_REPRO_DEBUG_ "Waiting for keystroke"
            read -n 1 key
            echo
            $_REPRO_DEBUG_ "The ${key} key was pressed"
            if [[ $key = 'q' ]] ; then
                $_REPRO_TRACE_RETURN_ "Returning because the 'q' key was pressed." ; return
            fi
        done
    else
         $_REPRO_TRACE_RETURN_ "Returning without waiting for a key press." ; return
    fi
}
