_TRACE_CALL_="repro.trace --call"
_TRACE_RETURN_="repro.trace --ret; return"

# returns seconds since the epoch
function repro.timestamp_seconds {
    echo $(date +"%s")
}

# returns a time-sortable dated timestamp
function repro.timestamp {
    echo $(date +"%Y-%m-%d %T")
}

function repro.alert {
    if [[ ${REPRO_VERBOSITY} != 'silent' ]] ; then
        echo $(repro.timestamp) 'ALERT |' $*
    fi
}

function repro.error {
    if [[ ${REPRO_VERBOSITY} != 'silent' ]] ; then
        echo $(repro.timestamp) 'ERROR |' $*
    fi
}

function repro.info {
    if [[ ${REPRO_VERBOSITY} == 'info'  || \
          ${REPRO_VERBOSITY} == 'debug' || \
          ${REPRO_VERBOSITY} == 'trace' ]] ; then
        echo $(repro.timestamp) ' INFO |' $*
    fi
}

function repro.debug {
    if [[ ${REPRO_VERBOSITY} == 'debug' || \
          ${REPRO_VERBOSITY} == 'trace' ]] ; then
        echo $(repro.timestamp) 'DEBUG |' "$*"
    fi
}

function repro.trace {

    [[ ${REPRO_VERBOSITY} != 'trace' ]] && return

    read line2 func2 file2  <<< "$(caller 0)"
    read line1 func1 file1  <<< "$(caller 1)"

    if [[ "$1" == "--call" ]] ; then
        shift
        arguments=" $(echo $* | xargs)"
        printf "%s TRACE | CALL %s -> %s%s [%s:%d -> %s:%d]\n" "$(repro.timestamp)" "${func1}" "${func2}" "${arguments}" "${file1}" "${line1}" "${file2}" "${line2}"
    else
        printf "%s TRACE | RET  %s <- %s [%s:%d <- %s:%d]\n" "$(repro.timestamp)" "${func1}" "${func2}" "${file1}" "${line1}" "${file2}" "${line2}"
    fi
}

function repro.initialize_state { $_TRACE_CALL_ "$*"
    mkdir -p ${REPRO_STATE_DIR}
    repro.timestamp > ${REPRO_START_TIME}
    repro.update_path
    repro.initialize_modules
    repro.update_targets
    repro.start_services --at-start
    $_TRACE_RETURN_
}

function repro.get_prefix_paths { $_TRACE_CALL_ "$*"
    unset prefix_paths
    readarray paths < ${REPRO_PATH_FILE}
    for path_line in "${paths[@]}" ; do
        new_path=$(echo "$path_line" | envsubst | xargs )
        if [[ -vprefix_paths ]] ; then
           prefix_paths=${new_path}:${prefix_paths}
        else
           prefix_paths=${new_path}
        fi
    done
    echo ${prefix_paths}
    $_TRACE_RETURN_
}

function repro.module_install_dir {
    module_name=$1
    read -ra tokens < ${REPRO_INDEX_DIR}/${module_name}
    module_install_dir=${tokens[2]}
    echo ${module_install_dir}
}

function repro.module_dot_dir {
    module_name=$1
    dot_dir=${REPRO_MNT}/.${module_name}
    echo ${dot_dir}
}

function repro.get_module_paths { $_TRACE_CALL_ "$*"
    unset module_paths
    readarray modules < ${REPRO_ORDER_FILE}
    for module_name in "${modules[@]}" ; do
        module_install_dir=$(repro.module_install_dir ${module_name})
        if [[ -v module_paths ]] ; then
            module_paths=${module_install_dir}:${module_paths}
        else
            module_paths=${module_install_dir}
        fi
    done
    echo ${module_paths}
    $_TRACE_RETURN_
}

function repro.update_path { $_TRACE_CALL_ "$*"

    updated_path=${REPRO_BASE_PATH}

    module_paths=$(repro.get_module_paths)
    if [[ ! -z ${module_paths} ]] ; then
        updated_path=${module_paths}:${updated_path}
    fi

   prefix_paths=$(repro.get_prefix_paths)
    if [[ ! -z ${prefix_paths} ]] ; then
        updated_path=${prefix_paths}:${updated_path}
    fi

    export PATH=${updated_path}

    $_TRACE_RETURN_
}

function ensure_nullglob {
    shopt -q nullglob
    if [[ $? == 1 ]] ; then
        null_glob_was_enabled=true
        shopt -s nullglob
    fi
}

function restore_nullglob {
    if [[ -v null_glob_was_enabled ]] ; then
        shopt -u nullglob
        unset null_glob_was_enabled
    fi
}

function repro.initialize_module_trim { $_TRACE_CALL_ "$*"

    module_name=$1

    # create module dot directory if it does not exist
    dot_dir=$(repro.module_dot_dir ${module_name})
    [[ -d ${dot_dir} ]] || mkdir -p ${dot_dir}

    # include a default .gitignore file
    git_ignore_file=${dot_dir}/.gitignore
    [[ -f ${git_ignore_file} ]] || echo "*" > ${git_ignore_file}

    # include any Makefiles found in the module installation directory
    install_dir=$(repro.module_install_dir ${module_name})
    ensure_nullglob
    makefiles=( ${install_dir}/Makefile-* )
    for makefile_path in "${makefiles[@]}" ; do
        makefile_name=$(basename ${makefile_path})
        cp --no-clobber ${install_dir}/${makefile_name} ${dot_dir}/${makefile_name}
    done
    restore_nullglob

    # copy module files listed in trun manifest if present
    trim_manifest=${install_dir}/manifest-trim
    if [[ -f ${trim_manifest} ]] ; then
        readarray trim_manifest_lines < ${trim_manifest}
        for trim_file_line in "${trim_manifest_lines[@]}" ; do
            trim_file=$(echo ${trim_file_line%%#*} | xargs)
            if [[ -n ${trim_file} ]] ; then
                cp --no-clobber ${install_dir}/${trim_file} ${dot_dir}/${trim_file}
            fi
        done
    fi

    $_TRACE_RETURN_
}

function repro.initialize_modules { $_TRACE_CALL_ "$*"
    readarray modules < ${REPRO_ORDER_FILE}
    for module in "${modules[@]}" ; do
        repro.initialize_module_trim ${module}
    done
    $_TRACE_RETURN_
}

function repro.update_targets { $_TRACE_CALL_ "$*"

    # do nothing if targets file already exists
    if [[ -f ${REPRO_TARGETS_FILE} ]] ; then
        $_TRACE_RETURN_
    else
        repro_builder_install_dir=$(repro.module_install_dir repro)
        cp  ${repro_builder_install_dir}/${REPRO_TARGETS_FILENAME} ${REPRO_TARGETS_FILE}
    fi

    readarray modules < ${REPRO_ORDER_FILE}
    for modules_line in "${modules[@]}" ; do
        module_name=$(echo $modules_line | xargs)
        install_dir=$(repro.module_install_dir ${module_name})

        for profile in base trim code demos util; do
            module_targets_file=${install_dir}/targets-${profile}
            if [[ -f ${module_targets_file} ]] ; then
                repro_targets=''
                readarray module_targets < ${module_targets_file}
                for target_entry in "${module_targets[@]}" ; do
                    read -ra tokens <<< ${target_entry}
                    repro_target=${tokens[0]}
                    module_target=${tokens[1]}
                    printf '%s %s.%s.%s\n' ${repro_target} ${module_name} ${profile} ${module_target} >> ${REPRO_TARGETS_FILE}
                done
            fi
        done
    done
    $_TRACE_RETURN_
}

function repro.run_target { $_TRACE_CALL_ "$*"

    requested_target=$1
    options=$2

    if [[ ! -f ${REPRO_TARGETS_FILE} ]] ; then
        $_TRACE_RETURN_
    fi

    readarray targets_file_lines < ${REPRO_TARGETS_FILE}

    for target_entry in "${targets_file_lines[@]}" ; do
        read -ra tokens <<< ${target_entry}
        if [[ ${tokens[0]} == ${requested_target}: ]] ; then
            IFS='.' read module_name profile module_target <<< ${tokens[1]}
            make --quiet -C ${REPRO_MNT}/.${module_name} -f Makefile-${profile} ${module_target}

            if [[ ${requested_target} == "start-services" ]] ; then
                repro.timestamp > ${REPRO_SERVICES_START_TIME}
                repro.announce_services
            fi

            $_TRACE_RETURN_
        fi
    done
    if [[ $options != "--quiet" ]] ; then
        repro.error "The $requested_target target is not implemented by this REPRO."
    fi

    $_TRACE_RETURN_
}

function repro.announce_services { $_TRACE_CALL_ "$*"

    # nothing to do if the repro services file is missing
    if [[ ! -f ${REPRO_SERVICES_FILE} ]] ; then
        repro.debug File not found: ${REPRO_SERVICES_FILE}
        $_TRACE_RETURN_
    fi

    # write a message to the terminal for each service
    readarray lines < ${REPRO_SERVICES_FILE}
    if [[ -n "${lines}" ]] ; then
        for line in "${lines[@]}" ; do
            read service_name internal_port external_port <<< ${line}
            repro.info The ${service_name} service is now running.
            repro.info Connect to ${service_name} at http://localhost:${external_port}.
        done
    else
        repro.debug No registered services to start.
    fi

    $_TRACE_RETURN_
}


function repro.start_services { $_TRACE_CALL_ "$*"

    # handle case where this function is being called during REPRO startup
    if [[ "$1" == "--at-start" ]] ; then

        # only start the services if auto-startup is enabled
        if [[ "${REPRO_SERVICES}" == 'auto' ]] ; then

            # use the --quiet option to hide warning when REPRO has no services
            repro.run_target start-services --quiet
        fi

        # no more to do if function was called during REPRO startup
        $_TRACE_RETURN_
    fi

    # this function is being called after startup so start the services
    # now only if service startup is configured to be manual
    if [[ "${REPRO_SERVICES}" == 'manual' ]] ; then

        # start services and allow warning that REPRO has no services
        repro.run_target start-services

        # an error code indicates that there were no services to start
        # so there is nothing else to do
        if [[ $? -ne 0 ]] ; then
            $_TRACE_RETURN_
        fi
    fi

    # the current call to this function started the services after REPRO
    # startup

    # wait for a key stroke before returning if requested

    if [[ "$1" == "--wait-for-key" ]] ; then
        while [ true ] ; do
            repro.alert "Type 'q' key to stop the REPRO and its services."
            read -n 1 key
            if [[ $key = 'q' ]] ; then
                echo
                exit
            fi
            echo
        done
    fi

    $_TRACE_RETURN_
}
