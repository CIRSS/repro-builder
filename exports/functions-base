

function repro.initialize_state { $_REPRO_TRACE_CALL_ $*
    mkdir -p ${REPRO_STATE_DIR}
    _repro.timestamp > ${REPRO_START_TIME}
    repro.update_path
    repro.initialize_modules
    repro.update_targets

	$_REPRO_DEBUG_ "Triggering automatic service startup if so configured"
    repro.start_services --at-start
    $_REPRO_TRACE_RETURN_
}

function repro.get_prefix_paths { $_REPRO_TRACE_CALL_ $*
    unset prefix_paths
    readarray paths < ${REPRO_PATH_FILE}
    for path_line in "${paths[@]}" ; do
        new_path=$(echo "$path_line" | envsubst | xargs )
        if [[ -vprefix_paths ]] ; then
           prefix_paths=${new_path}:${prefix_paths}
        else
           prefix_paths=${new_path}
        fi
    done
    echo ${prefix_paths}
    $_REPRO_TRACE_RETURN_
}

function repro.module_install_dir {
    module_name=$1
    read -ra tokens < ${REPRO_INDEX_DIR}/${module_name}
    module_install_dir=${tokens[2]}
    echo ${module_install_dir}
}

function repro.module_dot_dir {
    module_name=$1
    dot_dir=${REPRO_MNT}/.${module_name}
    echo ${dot_dir}
}

function repro.get_module_paths { $_REPRO_TRACE_CALL_ $*
    unset module_paths
    readarray modules < ${REPRO_ORDER_FILE}
    for module_name in "${modules[@]}" ; do
        module_install_dir=$(repro.module_install_dir ${module_name})
        if [[ -v module_paths ]] ; then
            module_paths=${module_install_dir}:${module_paths}
        else
            module_paths=${module_install_dir}
        fi
    done
    echo ${module_paths}
    $_REPRO_TRACE_RETURN_
}

function repro.update_path { $_REPRO_TRACE_CALL_ $*

    updated_path=${REPRO_BASE_PATH}

    module_paths=$(repro.get_module_paths)
    if [[ ! -z ${module_paths} ]] ; then
        updated_path=${module_paths}:${updated_path}
    fi

   prefix_paths=$(repro.get_prefix_paths)
    if [[ ! -z ${prefix_paths} ]] ; then
        updated_path=${prefix_paths}:${updated_path}
    fi

    export PATH=${updated_path}

    $_REPRO_TRACE_RETURN_
}

function _repro.ensure_nullglob {
    shopt -q nullglob
    if [[ $? == 1 ]] ; then
        $_REPRO_TRACE_ "Enabling nullglob shell option"
        shopt -s nullglob
        null_glob_was_enabled=true
    fi
}

function _repro.restore_nullglob {
    if [[ -v null_glob_was_enabled ]] ; then
        $_REPRO_TRACE_ "Restoring nullglob shell option to disabled state"
        shopt -u nullglob
        unset null_glob_was_enabled
    fi
}

function repro.initialize_module_trim { $_REPRO_TRACE_CALL_ $*

    module_name=$1

	$_REPRO_DEBUG_ "Initializing trim files for module '${module_name}'"

    # create module dot directory if it does not exist
    dot_dir=$(repro.module_dot_dir ${module_name})
    if [[ ! -d ${dot_dir} ]] ; then
        $_REPRO_DEBUG_ "Creating the module '${module_name}' trim directory (${dot_dir})"
         mkdir -p ${dot_dir}
    fi

    # include a default .gitignore file
    git_ignore_file=${dot_dir}/.gitignore
    if [[ ! -f ${git_ignore_file} ]] ; then
        $_REPRO_DEBUG_ "Creating a .gitignore file that ignores everything in the trim directory (${dot_dir})"
        echo "*" > ${git_ignore_file}
    fi

    # include any Makefiles found in the module installation directory
    install_dir=$(repro.module_install_dir ${module_name})
    $_REPRO_DEBUG_ "Looking for Makefiles in the '${module_name}' module installation directory (${install_dir}) to copy to the module trim directory (${dot_dir})"
    _repro.ensure_nullglob
    makefiles=( ${install_dir}/Makefile-* )
    for makefile_path in "${makefiles[@]}" ; do
        makefile_name=$(basename ${makefile_path})

        if [[ -f ${dot_dir}/${makefile_name} ]] ; then
            $_REPRO_DEBUG_ "The file ${makefile_name} is already present in the '${module_name}' trim directory (${dot_dir})"
        else
            $_REPRO_DEBUG_ "Copying ${install_dir}/${makefile_name} to the '${module_name}' trim directory (${dot_dir})"
            cp ${install_dir}/${makefile_name} ${dot_dir}/${makefile_name}
        fi
    done
    _repro.restore_nullglob

    # copy module files listed in trim manifest if present
    trim_manifest=${install_dir}/manifest-trim
    if [[ -f ${trim_manifest} ]] ; then
        $_REPRO_DEBUG_ "Ensuring other files listed in the trim manifest for module ${module_name} are in the module dot directory (${dot_dir})"
        readarray trim_manifest_lines < ${trim_manifest}
        for trim_file_line in "${trim_manifest_lines[@]}" ; do
            trim_file=$(echo ${trim_file_line%%#*} | xargs)
            if [[ -n ${trim_file} ]] ; then
                if [[ -f  ${dot_dir}/${trim_file} ]] ; then
                    $_REPRO_DEBUG_ "Trim file ${trim_file} is already present in ${dot_dir}"
                else
                    $_REPRO_DEBUG_ "Copying trim file ${trim_file} from ${install_dir} to ${dot_dir}"
                    cp ${install_dir}/${trim_file} ${dot_dir}/${trim_file}
                fi
            fi
        done
    fi

    $_REPRO_TRACE_RETURN_ "Done initializing trim files for module '${module_name}'" ; return
}

function repro.initialize_modules { $_REPRO_TRACE_CALL_ $*
    $_REPRO_INFO_ "Initializing REPRO modules"
    $_REPRO_DEBUG_ "Iterating over the list of installed modules in the module order file (${REPRO_ORDER_FILE})"
    readarray modules < ${REPRO_ORDER_FILE}
    for module in "${modules[@]}" ; do
        $_REPRO_DEBUG_ "Initializing module '${module}'"
        repro.initialize_module_trim ${module}
    done
    $_REPRO_TRACE_RETURN_ "Done inializing modules"
}

function repro.update_targets { $_REPRO_TRACE_CALL_ $*

    $_REPRO_DEBUG_ "Ensuring that the global target mapping file (${REPRO_TARGETS_FILE}) exists"

    # do nothing if targets file already exists
    if [[ -f ${REPRO_TARGETS_FILE} ]] ; then
      $_REPRO_TRACE_RETURN_ "The global target mapping file (${REPRO_TARGETS_FILE}) already exists so nothing to do." ; return
    fi

    $_REPRO_DEBUG_ "Installing a default (empty) target mapping file to ${REPRO_TARGETS_FILE}"
    repro_builder_install_dir=$(repro.module_install_dir repro)
    cp  ${repro_builder_install_dir}/${REPRO_TARGETS_FILENAME} ${REPRO_TARGETS_FILE}

    $_REPRO_DEBUG_ "Iterating over the list of installed modules in the module order file (${REPRO_ORDER_FILE})"
    readarray modules < ${REPRO_ORDER_FILE}
    for modules_line in "${modules[@]}" ; do
        module_name=$(echo $modules_line | xargs)
        install_dir=$(repro.module_install_dir ${module_name})

        $_REPRO_DEBUG_ "Looking for targets in the '${module_name}' module"
        for profile in base trim code demos util; do
            module_targets_file=${install_dir}/targets-${profile}
            if [[ -f ${module_targets_file} ]] ; then
                repro_targets=''
                readarray module_targets < ${module_targets_file}
                for target_entry in "${module_targets[@]}" ; do
                    read -ra tokens <<< ${target_entry}
                    repro_target=${tokens[0]%?} # trims last character (':') from token 0 to get the module name
                    module_target=${tokens[1]}
                    $_REPRO_DEBUG_ "Mapping the '${module_target}' target in the '${profile}' profile of the '${module_name}' module to the global '${repro_target}' target"
                    printf '%s: %s.%s.%s\n' ${repro_target} ${module_name} ${profile} ${module_target} >> ${REPRO_TARGETS_FILE}
                done
            fi
        done
    done

    $_REPRO_TRACE_RETURN_ 'Done building the global target mapping file'
}

function repro.run_target { $_REPRO_TRACE_CALL_ $*

    requested_target=$1
    options=$2

    if [[ ! -f ${REPRO_TARGETS_FILE} ]] ; then
        $_REPRO_TRACE_RETURN_ "No global target mapping file (${REPRO_TARGETS_FILE}) found." ; return
    fi

    readarray targets_file_lines < ${REPRO_TARGETS_FILE}

    for target_entry in "${targets_file_lines[@]}" ; do
        read -ra tokens <<< ${target_entry}
        $_REPRO_DEBUG_ Processing line in target file: ${tokens}
        if [[ ${tokens[0]} == ${requested_target}: ]] ; then
            IFS='.' read module_name profile module_target <<< ${tokens[1]}
            make ${REPRO_MAKE_VERBOSITY} -C ${REPRO_MNT}/.${module_name} -f Makefile-${profile} ${module_target}

            if [[ ${requested_target} == "start-services" ]] ; then
                _repro.timestamp > ${REPRO_SERVICES_START_TIME}
                repro.announce_services
            fi

            $_REPRO_TRACE_RETURN_ ; return
        fi
    done
    if [[ $options != "--quiet" ]] ; then
        $_REPRO_ERROR_ "The '$requested_target' target is not implemented."
    fi

    $_REPRO_TRACE_RETURN_
}

function repro.announce_services { $_REPRO_TRACE_CALL_ $*

    # nothing to do if the repro services file is missing
    if [[ ! -f ${REPRO_SERVICES_FILE} ]] ; then
        $_REPRO_TRACE_RETURN_ "File not found: ${REPRO_SERVICES_FILE}" ; return
    fi

    # write a message to the terminal for each service
    readarray lines < ${REPRO_SERVICES_FILE}
    if [[ -n "${lines}" ]] ; then
        for line in "${lines[@]}" ; do
            read service_name internal_port external_port <<< ${line}
            $_REPRO_INFO_ The ${service_name} service is now running.
            $_REPRO_INFO_ Connect to ${service_name} at http://localhost:${external_port}.
        done
    else
        $_REPRO_DEBUG_ No registered services to start.
    fi

    $_REPRO_TRACE_RETURN_
}


function repro.start_services { $_REPRO_TRACE_CALL_ $*

    if [[ "$1" == "--at-start" ]] ; then
        $_REPRO_DEBUG_ "The function ${FUNCNAME[0]} is being called during startup"

        if [[ "${REPRO_SERVICES_STARTUP}" == 'auto' ]] ; then
			$_REPRO_DEBUG_ 'Starting services now because REPRO_SERVICES_STARTUP == auto'
            $_REPRO_DEBUG_ "Invoking the 'start-services' target with the --quiet option to
                            hide warning when REPRO has no services"
            repro.run_target start-services --quiet
        else
			$_REPRO_DEBUG_ 'The services are not being started now because REPRO_SERVICES_STARTUP != auto'
		fi

        $_REPRO_TRACE_RETURN_ "Done handling ${FUNCNAME[0]} call during startup" ; return
    fi

    $_REPRO_DEBUG_ "The function ${FUNCNAME[0]} is being called *after* startup"

    # now only if service startup is configured to be manual
    if [[ "${REPRO_SERVICES_STARTUP}" == 'manual' ]] ; then

		$_REPRO_DEBUG_ 'Starting services now because REPRO_SERVICES_STARTUP == manual'

		# start services and allow warning that REPRO has no services
        repro.run_target start-services
        return_code=$?

        # an error code indicates that there were no services to start
        # so there is nothing else to do
        if [[ $return_code -ne 0 ]] ; then
            $_REPRO_DEBUG_ "The return code of $return_code indicates there were no services to start"
            $_REPRO_TRACE_RETURN_ "Because no services were started there is nothing left to do"; return
        fi
    else
        $_REPRO_DEBUG_ 'The services are not being started now because REPRO_SERVICES_STARTUP != manual'
    fi

    if [[ "$1" == "--wait-for-key" ]] ; then
        $_REPRO_DEBUG_ "Will now wait for a key stroke before returning because the --wait-for-key option was given"
        while [ true ] ; do
            $_REPRO_ALERT_ "Press the 'q' key to stop the REPRO and its services."
            $_REPRO_DEBUG_ "Waiting for keystroke"
            read -n 1 key
            echo
            $_REPRO_DEBUG_ "The ${key} key was pressed"
            if [[ $key = 'q' ]] ; then
                $_REPRO_TRACE_RETURN_ "Returning because the 'q' key was pressed." ; return
            fi
        done
    else
         $_REPRO_TRACE_RETURN_ "Returning without waiting for a key press." ; return
    fi
}
