

# ensure this file is sourced only once
if [[ "$REPRO_LOGGING_FILE_SOURCED" == true ]] ; then
    repro.trace_source
    repro.trace REPRO logging functions already loaded.
    ${_TRACE_RETURN_}
    return
else
    REPRO_LOGGING_FILE_SOURCED=true
fi

function repro.alert {
    if [[ ${REPRO_LOGGING} != 'none' ]] ; then
        _repro.log A MESG $*
    fi
}

function repro.error {
    if [[ ${REPRO_LOGGING} != 'none' ]] ; then
        _repro.log E MESG $*
    fi
}

function repro.warn {
    if [[ ${REPRO_LOGGING} != 'none'  && \
          ${REPRO_LOGGING} != 'alert' ]] ; then
        _repro.log W MESG $*
    fi
}

function repro.info {
    if [[ ${REPRO_LOGGING} == 'info'  || \
          ${REPRO_LOGGING} == 'debug' || \
          ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log I MESG $*
    fi
}

function repro.debug {
    if [[ ${REPRO_LOGGING} == 'debug' || \
          ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log D MESG $*
    fi
}

function repro.trace {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log T MESG $*
    fi
}

function repro.trace_source {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        if [[ -n $1 ]] ; then
            REPRO_TRACE_SOURCE=$1
        else
            _repro.log T SRCE "${REPRO_TRACE_SOURCE} -> $(_repro.caller_file 0)"
            unset REPRO_TRACE_SOURCE
        fi
    fi
}

function repro.trace_call {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        arguments=" $(echo $* | xargs)"
        printf -v location "[%s -> %s]" "$(_repro.caller 1)" "$(_repro.caller 0)"
        printf -v message "%s -> %s%s" "$(_repro.caller_func 1)" "$(_repro.caller_func 0)" "${arguments}"
        _repro.log --location "$location" T CALL $message
    fi
}

function repro.trace_ret {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        printf -v location "[%s <- %s]" "$(_repro.caller 1)" "$(_repro.caller 0)"
        printf -v message "%s <- %s" "$(_repro.caller_func 1)" "$(_repro.caller_func 0)"
        _repro.log --location "$location" T RETN $message
    fi
}

# returns seconds since the epoch
function _repro.timestamp_seconds {
    echo $(date +"%s")
}

# returns a time-sortable dated timestamp
function _repro.timestamp {
    echo "$(date +'%Y-%m-%d %T') "
}

function _repro.caller_file {
	stack_level=$1
	read _ _ file  <<< "$(caller $(($stack_level+1)))"
	echo $file
}

function _repro.caller_func {
	stack_level=$1
	read _ func _  <<< "$(caller $(($stack_level+1)))"
	echo $func
}

function _repro.caller {
	stack_level=$1
	read line func file  <<< "$(caller $(($stack_level+1)))"
	printf "%s:%s:%s\n" "$file" "$func" "$line"
}

function _repro.create_log_dir {
    export REPRO_LOG_DIR=${REPRO_MNT}/.repro-log
    if [[ ! -d ${REPRO_LOG_DIR} ]] ; then
        mkdir ${REPRO_LOG_DIR}
        echo "*" > ${REPRO_LOG_DIR}/.gitignore
    fi
}

function _repro.create_log_file {
    _repro.create_log_dir
    REPRO_RUN_LOG_FILE=${REPRO_LOG_DIR}/log.txt
    touch ${REPRO_RUN_LOG_FILE}
}

function _repro.initialize_logging {
    if [[ $REPRO_LOGGING_OPTIONS != *"NO_TIMESTAMPS"* ]]; then
        REPRO_LOGGING_TIMESTAMPS=true
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_LOCATIONS"* ]]; then
        REPRO_LOGGING_LOCATIONS=true
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_FILE"* ]]; then
        REPRO_LOG_TO_FILE=true
        _repro.create_log_file
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_TERMINAL"* ]]; then
        REPRO_LOG_TO_TERMINAL=true
    fi
}

function _repro.log {

    # support an --location option overriding the default source location
    location=''
    if [[ "$1" == "--location" ]] ; then
        if [[ ${REPRO_LOGGING_LOCATIONS} == 'true' ]] ; then
            location=" $2"
        fi
        shift 2
    else
        if [[ ${REPRO_LOGGING_LOCATIONS} == 'true' ]] ; then
            printf -v location " [%s]" "$(_repro.caller 1)"
        fi
    fi

    level="$1"  # first argument indicates the logging level of the entry
    type="$2"   # second argument indicates the type of the entry body

    shift 2
    arguments="$*"

    timestamp=''
    if [[ ${REPRO_LOGGING_TIMESTAMPS} == 'true' ]] ; then
        timestamp="$(_repro.timestamp)"
    fi

    printf -v entry "%s%s %s %s%s" "$timestamp" "$level" "$type" "$arguments" "$location"

    if [[ ${REPRO_LOG_TO_TERMINAL} == 'true' ]] ; then
        echo "$entry" >&2
    fi

    if [[ ${REPRO_LOG_TO_FILE} == 'true' ]] ; then
        echo "$entry" >> ${REPRO_RUN_LOG_FILE}
    fi
}

# define REPRO tracing macros
_TRACE_CALL_="repro.trace_call"
_TRACE_RETURN_="repro.trace_ret ; return"

# initialize logger state
_repro.initialize_logging

# report definition of logging functions succeeeded
repro.trace_source
repro.trace "Loaded REPRO logging functions"

${_TRACE_RETURN_}
