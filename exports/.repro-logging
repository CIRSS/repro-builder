# ensure this file is sourced only once
if [[ "$REPRO_LOGGING_FILE_SOURCED" == true ]] ; then
    $_REPRO_TRACE_SOURCE_
    $_REPRO_TRACE_RETURN_ 'Logging functions already loaded' ; return
else
    REPRO_LOGGING_FILE_SOURCED=true
fi

function repro.alert {
    if [[ ${REPRO_LOGGING} != 'none' ]] ; then
        _repro.log A MESG $*
    fi
}

function repro.error {
    if [[ ${REPRO_LOGGING} != 'none' ]] ; then
        _repro.log E MESG $*
    fi
}

function repro.warn {
    if [[ ${REPRO_LOGGING} != 'none'  && \
          ${REPRO_LOGGING} != 'alert' ]] ; then
        _repro.log W MESG $*
    fi
}

function repro.info {
    if [[ ${REPRO_LOGGING} == 'info'  || \
          ${REPRO_LOGGING} == 'debug' || \
          ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log I MESG $*
    fi
}

function repro.debug {
    if [[ ${REPRO_LOGGING} == 'debug' || \
          ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log D MESG $*
    fi
}

function repro.trace {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        _repro.log T MESG $*
    fi
}

function repro.trace_source {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        if [[ -n $1 ]] ; then
            REPRO_TRACE_SOURCE=$1
        else
            _repro.log T SRCE "${REPRO_TRACE_SOURCE} -> $(_repro.caller_file 0)"
            unset REPRO_TRACE_SOURCE
        fi
    fi
}

function repro.trace_call {
    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        arguments=" $(echo $* | xargs)"
        printf -v location "[%s -> %s]" "$(_repro.caller 1)" "$(_repro.caller 0)"
        printf -v message "%s -> %s%s" "$(_repro.caller_func 1)" "$(_repro.caller_func 0)" "${arguments}"
        _repro.log --location "$location" T CALL $message
    fi
}

function repro.trace_ret {

	if [[ -n "$*" && ( ${REPRO_LOGGING} == 'trace' || ${REPRO_LOGGING} == 'debug' ) ]] ; then
			_repro.log D MESG $*
	fi

    if [[ ${REPRO_LOGGING} == 'trace' ]] ; then
        printf -v location "[%s <- %s]" "$(_repro.caller 1)" "$(_repro.caller 0)"
        printf -v message "%s <- %s" "$(_repro.caller_func 1)" "$(_repro.caller_func 0)"
        _repro.log --location "$location" T RETN $message
    fi
}

# returns seconds since the epoch
function _repro.timestamp_seconds {
    echo $(date +"%s")
}

#  returns a sortable timestamp
function _repro.timestamp {
    echo "$(date +'%Y-%m-%d %T.%3N')"
}

# returns a sortable timestamp with no spaces
function _repro.timestamp_nospaces {
    echo "$(date +'%Y%m%d.%H%M%S.%3N')"
}

function _repro.caller_file {
	stack_level=$1
	read _ _ file  <<< "$(caller $(($stack_level+1)))"
	echo $file
}

function _repro.caller_func {
	stack_level=$1
	read _ func _  <<< "$(caller $(($stack_level+1)))"
	echo $func
}

function _repro.caller {
	stack_level=$1
	read line func file  <<< "$(caller $(($stack_level+1)))"
	printf "%s:%s:%s\n" "$file" "$func" "$line"
}

function _repro.create_log_dir {
    export REPRO_LOG_DIR=${REPRO_MNT}/.repro-log
    if [[ ! -d ${REPRO_LOG_DIR} ]] ; then
        mkdir ${REPRO_LOG_DIR}
        echo "*" > ${REPRO_LOG_DIR}/.gitignore
    fi
}

function _repro.create_log_file {
    _repro.create_log_dir
    REPRO_RUN_LOG_FILE="${REPRO_LOG_DIR}/$(_repro.timestamp_nospaces).log"
    touch ${REPRO_RUN_LOG_FILE}
}

function _repro.log {

    # support an --location option overriding the default source location
    location=''
    if [[ "$1" == "--location" ]] ; then
        if [[ ${REPRO_LOGGING_LOCATIONS} == 'true' ]] ; then
            location=" $2"
        fi
        shift 2
    else
        if [[ ${REPRO_LOGGING_LOCATIONS} == 'true' ]] ; then
            printf -v location " [%s]" "$(_repro.caller 1)"
        fi
    fi

    level="$1"  # first argument indicates the logging level of the entry
    type="$2"   # second argument indicates the type of the entry body

    shift 2
    arguments="$*"

    timestamp=''
    if [[ ${REPRO_LOGGING_TIMESTAMPS} == 'true' ]] ; then
        timestamp="$(_repro.timestamp_nospaces) "
    fi

    printf -v entry "%s%s %s %s%s" "$timestamp" "$level" "$type" "$arguments" "$location"

    if [[ ${REPRO_LOG_TO_TERMINAL} == 'true' ]] ; then
        echo "$entry" >&2
    fi

    if [[ ${REPRO_LOG_TO_FILE} == 'true' ]] ; then
        echo "$entry" >> ${REPRO_RUN_LOG_FILE}
    fi
}

function _repro.initialize_logging {

    # if logging is disabled set logging macros to do nothing
    if [[ ${REPRO_LOGGING} == 'none' ]] ; then
        export _REPRO_ALERT_=:
        export _REPRO_ERROR_=:
        export _REPRO_WARN_=:
        export _REPRO_INFO_=:
        export _REPRO_DEBUG_=:
        export _REPRO_TRACE_=:
        export _REPRO_TRACE_CALL_=:
        export _REPRO_TRACE_SOURCE_=:
        export _REPRO_TRACE_RETURN_='return ; '
        return
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_TIMESTAMPS"* ]] ; then
        REPRO_LOGGING_TIMESTAMPS=true
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_LOCATIONS"* ]] ; then
        REPRO_LOGGING_LOCATIONS=true
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_FILE"* ]] ; then
        REPRO_LOG_TO_FILE=true
        _repro.create_log_file
    fi

    if [[ $REPRO_LOGGING_OPTIONS != *"NO_TERMINAL"* ]] ; then
        REPRO_LOG_TO_TERMINAL=true
    fi

    # define logging macros
    export _REPRO_ALERT_=repro.alert
    export _REPRO_ERROR_=repro.error
    export _REPRO_WARN_=repro.warn
    export _REPRO_INFO_=repro.info
    export _REPRO_DEBUG_=repro.debug
    export _REPRO_TRACE_=repro.trace
    export _REPRO_TRACE_CALL_=repro.trace_call
    export _REPRO_TRACE_SOURCE_=repro.trace_source
    export _REPRO_TRACE_RETURN_=repro.trace_ret

	$_REPRO_TRACE_RETURN_
}

# initialize logger state
_repro.initialize_logging

# report definition of logging functions succeeeded
$_REPRO_TRACE_SOURCE_
$_REPRO_TRACE_RETURN_ 'Finished loaded logging functions'
